# SECTION 3.1 - MODELUL MATEMATIC AL FUNCȚIEI DE FITNESS - UPDATE

## 3.1 Modelul Matematic al Funcției de Fitness

### 3.1.1 Fundamentarea Teoretică

Funcția de fitness este fundamentul evaluării ergonomice a layout-urilor de tastatură în cadrul proiectului ErgoType.2. Acest model matematic integrează principii biomecanice, ergonomice și statistice pentru a cuantifica eficiența unui layout în termeni de efort fizic, viteză de tastare și confort utilizator.

### 3.1.2 Legea lui Fitts în Evaluarea Tastării

Modelul se bazează pe **Legea lui Fitts**, o relație fundamentală din domeniul interacțiunii om-calculator care estimează timpul necesar pentru a atinge un țintă cu un efector (în acest caz, degetul către o tastă). Formula clasică este:

**T = a + b × log₂(D/W + 1)**

unde:
- T = timpul de mișcare estimat
- D = distanța de la poziția curentă a degetului până la tastă
- W = lățimea (dimensiunea) țintei (tastei) în direcția mișcării
- a, b = parametri empirici care depind de dispozitiv și utilizator

### 3.1.3 Implementarea Modelului în Proiect

#### 3.1.3.1 Componentele Funcției de Fitness

Se presupune un text de intrare compus din N caractere/apasări de taste (după mapare), parcurs secvențial de la k = 1 la k = N.

**Funcția de fitness este exprimată prin formula:**

F = w_d × n(D_total) + w_t × n(T_total)

unde:
- F = scorul de fitness (scop: minimizare)
- w_d, w_t = ponderi pentru termenii de distanță și timp (se utilizează w_d = w_t = 0.5)
- n(·) = funcție de normalizare pe intervalul [0,1], cu X_min = 0 și X_max determinat în timpul simulării

#### 3.1.3.2 Calculul Distanței Totale

Distanța totală reprezintă suma deplasărilor fiecărui deget pentru a ajunge la tastele corespunzătoare caracterelor în timpul tastării:

D_total = Σ(k=1,N) d_k

unde d_k este distanța parcursă de degetul f_k = π(k) pentru a ajunge la tasta corespunzătoare apăsării k.

**Calculul distanței parcurse:**

d_k = √[(x(k) - x_(k-1)^(f_k))² + (y(k) - y_(k-1)^(f_k))²]

Componentele principale ale acestei formule sunt:
- (x(k), y(k)) = poziția tastei în planul cartezian
- (x_(k-1)^(f), y_(k-1)^(f)) = poziția curentă a degetului f după pasul k-1

**Actualizarea pozițiilor:**
După apăsarea k, poziția degetului este actualizată:
(x_k^(f_k), y_k^(f_k)) ← (x(k), y(k))

Pentru celelalte degete (g ≠ f_k), pozițiile rămân neschimbate:
(x_k^(g), y_k^(g)) ← (x_(k-1)^(g), y_(k-1)^(g))

#### 3.1.3.3 Calculul Timpului Total

Timpul total necesar pentru a parcurge textul reprezintă suma timpilor de execuție pentru toate mișcările și apăsările de taste simulate:

T_total = Σ(g=1,G) T_group^(g)

unde G este numărul total de grupuri de apăsări.

**Gruparea apăsărilor:**
Tastarea întregului text poate fi privită ca un proces compus din apăsări de taste care se succed rapid, unele dintre ele putând fi realizate simultan de degete diferite. Pentru a reflecta acest paralelism natural, grupăm apăsările consecutive în grupuri de apăsări, astfel încât fiecare deget să apară cel mult o singură dată în cadrul unui grup.

**Timpul pentru un grup:**
T_group^(g) = max(f∈F) [t_move^(f) + t_press^(f) + t_sync^(f)]

unde:
- t_move^(f) = timpul de mișcare conform Legii lui Fitts
- t_press^(f) = timpul de apăsare specific degetului f
- t_sync^(f) = penalizare de sincronizare (dacă este cazul)

#### 3.1.3.4 Normalizarea și Resetarea Pozițiilor

Pentru a evita biasul generat de texte foarte lungi și pentru a modela pauzele sau relaxările, pozițiile degetelor sunt resetate periodic. La fiecare M taste procesate, toate degetele revin la pozițiile lor „home":

(x_k^(f), y_k^(f)) ← (x_f^home, y_f^home), ∀f ∈ F

### 3.1.4 Implementare în Cod

#### 3.1.4.1 Fișier: core/distance_calculator.py

```python
class DistanceCalculator:
    def __init__(self, keyboard_file, keyboard, debug=False, 
                 fitts_a=0, fitts_b=150):
        """
        Initialize DistanceCalculator with Fitts's Law support.
        
        Args:
            keyboard_file: Path to keyboard layout file
            keyboard: Keyboard object
            debug: Enable debug printing
            fitts_a: Fitts's Law constant 'a' in milliseconds (default: 0)
            fitts_b: Fitts's Law constant 'b' in milliseconds (default: 150)
        """
        self.debug = debug
        self.fitts_a = fitts_a
        self.fitts_b = fitts_b
        # ... rest of implementation
```

#### 3.1.4.2 Calculul Distanței Euclidiene

```python
def cartesian_distance(point1: tuple, point2: tuple) -> float:
    """Calculate Euclidean distance between two points."""
    if len(point1) != len(point2):
        raise ValueError("Points must have the same dimension.")
    squared_differences_sum = sum((p1_coord - p2_coord) ** 2
                                  for p1_coord, p2_coord in zip(point1, point2))
    distance = math.sqrt(squared_differences_sum)
    return distance
```

#### 3.1.4.3 Aplicarea Legii lui Fitts

```python
def calculate_fitts_time(self, distance, width):
    """
    Calculate movement time using Fitts's Law.
    
    Args:
        distance: Distance to target
        width: Width of target (key)
        
    Returns:
        Movement time in milliseconds
    """
    if width <= 0:
        width = self.keyboard.key_width  # Default key width
    
    log_term = math.log2(distance / width + 1)
    time_ms = self.fitts_a + self.fitts_b * log_term
    return max(time_ms, 0)  # Ensure non-negative time
```

### 3.1.5 Coeficienții de Forță ai Degetelor

Funcția de fitness ține cont și de forța relativă a fiecărui deget, conform următoarelor valori:

```python
# src/config/finger_strength.py
FINGER_STRENGTH_MULTIPLIERS = {
    'pinky': 1.25,      # Cel mai slab
    'ring': 1.15,
    'index': 1.05,
    'middle': 1.00,     # Cel mai puternic
    'thumb': 1.10
}
```

Acești coeficienți sunt aplicați asupra costurilor calculate pentru fiecare deget, oferind o evaluare mai realistă a efortului necesar.

### 3.1.6 Cache-ul Distanțelor

Pentru eficiență computațională, distanțele dintre toate perechile de taste sunt precalculate și stocate în cache:

```python
# src/config/file_paths.py
DISTANCE_CACHE = os.path.join(PROJECT_ROOT, "src", "data", "distance", "distances.pkl")

# Implementare cache în distance_calculator.py
def load_cache(self):
    """Load precomputed distances from cache."""
    if os.path.exists(self.cache_file):
        with open(self.cache_file, 'rb') as f:
            self.distance_cache = pickle.load(f)

def save_cache(self):
    """Save computed distances to cache."""
    with open(self.cache_file, 'wb') as f:
        pickle.dump(self.distance_cache, f)
```

### 3.1.7 Integrarea cu C# pentru Performanță

Pentru calculele intensive de fitness, proiectul utilizează o bibliotecă C# care oferă performanță superioară:

```python
# src/core/clr_loader_helper.py
def load_csharp_fitness_library(project_root):
    """Load C# fitness calculation library using clr_loader."""
    import clr_loader
    from pythonnet import pythondll
    
    # Load .NET runtime
    rt_config = clr_loader.get_coreclr_rid(runtime_version="8.0.11")
    runtime = clr_loader.runtime.LoadRuntime(rt_config)
    
    # Load C# assembly
    assembly_path = os.path.join(project_root, "cs", "KeyboardFitness", "bin", "Release", "net8.0", "KeyboardFitness.dll")
    runtime.load_assembly(assembly_path)
    
    # Import types
    import clr
    from KeyboardFitness import Fitness
    
    return Fitness, runtime
```

### 3.1.8 Evaluare Paralelă

Pentru a accelera evaluarea populației, sistemul utilizează procesare paralelă:

```python
# src/core/ga.py
def _evaluate_individual_worker(individual_data, keyboard_file, text_file, 
                               finger_coefficients, fitts_a, fitts_b):
    """Worker function - each process evaluates ONE individual then exits"""
    try:
        individual_id, chromosome, name = individual_data
        
        # Initialize C# in this process
        from core.clr_loader_helper import load_csharp_fitness_library
        Fitness, _ = load_csharp_fitness_library(PROJECT_ROOT)
        
        # Create evaluator and run simulation
        evaluator = Evaluator(debug=False)
        evaluator.load_keyboard(keyboard_file)
        evaluator.load_layout()
        
        # Remap layout and evaluate
        qwerty_base = list(LAYOUT_DATA["qwerty"])
        evaluator.layout.remap(qwerty_base, chromosome)
        
        # Generate C# configuration and evaluate
        config = evaluator.generate_csharp_fitness_config(
            text_file, finger_coefficients, fitts_a, fitts_b
        )
        fitness_result = Fitness.EvaluateLayout(config)
        
        return individual_id, fitness_result.TotalFitness, chromosome, name
        
    except Exception as e:
        print(f"Worker {os.getpid()}: Error evaluating individual: {e}")
        return individual_id, float('inf'), chromosome, name
```

Această abordare asigură o evaluare rapidă și eficientă a fitness-ului pentru populații mari de layout-uri, permițând explorarea unui spațiu vast de soluții într-un timp rezonabil.